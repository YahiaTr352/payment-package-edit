const EncryptionKeyModel = require("../models/keysModel");

const paymentData = require("../models/paymentDataModel");
const {
  isValidString,
  isValidNumber,
  validateMerchantPhoneNumber,
  validateCustomerPhoneNumber,
  isValidAmount,
  isValidOTP
} = require("../utils/validation");
const {
  generateRSAKeyPair,
  encryptHybrid,
  decryptHybrid,
  sendEncryptedError,
  encryptKeyGCM,
  decryptKeyGCM
} = require('../utils/encryption');
const { generateKeyPairSync } = require('crypto');
const BASE_API_URL = process.env.BASE_SYRITAL_URL;
const { v4: uuidv4 } = require("uuid");
const axios = require("axios");
const getUrl = async (req, res) => {
  const { clientPublicKey } = req.body;
  const { companyName, programmName, code, merchantMSISDN, amount } = req.body;
  const isDevRequest = req.headers["x-dev-request"] === "true";

  if (!isValidString(companyName)) return isDevRequest ? res.status(400).json({message : "Invalid CompanyName"}) : res.status(204).end();
  if (!isValidString(programmName)) return isDevRequest ? res.status(400).json({message : "Invalid ProgrammName"}) : res.status(204).end();
  if (!isValidNumber(code)) return isDevRequest ? res.status(400).json({message : "Invalid Code"}) : res.status(204).end();
  if (!validateMerchantPhoneNumber(merchantMSISDN)) return isDevRequest ? res.status(400).json({message : "Invalid Merchant Phone Number"}) : res.status(204).end();
  if (!isValidAmount(amount)) return isDevRequest ? res.status(400).json({message : "Invalid Amount"}) : res.status(204).end();

  const transactionID = uuidv4();
  const publicID_phonePage = uuidv4();
  const publicID_otpPage = uuidv4();

  try {
    await paymentData.create({
          publicIDs: {
            phonePage: publicID_phonePage,
            otpPage: publicID_otpPage,
          },
      transactionID,
      companyName,
      programmName,
      code,
      merchantMSISDN,
      customerMSISDN : null,
      amount,
      otp: null,
      createdAt: new Date()
    });

    await EncryptionKeyModel.create({
      clientPublicKey : null,
      serverPrivateKey : null,
          publicIDs: {
            phonePage: publicID_phonePage,
            otpPage: publicID_otpPage,
          },
    });


    const baseUrl = process.env.BASE_PACKAGE_URL;
    const redirectUrl = `${baseUrl}/api/clients/customerPhone-page/${publicID_phonePage}`;
    return res.json({ url: redirectUrl });

  } catch (error) {
    console.error("Login error:", error);  // Ø§Ø·Ø¨Ø¹ Ø§Ù„Ø®Ø·Ø£ Ù‡Ù†Ø§
    return res.status(500).json({message : "Internal server error"});
  }
};

const getToken = async (req, res) => {
  const encryptedBody = req.body;

  let decryptedData;
  let pageID = encryptedBody.pageID; // âœ… Ø®Ø° pageID Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ÙÙ‘Ø±Ø©

  if (!pageID) {
    return res.status(400).json({ message: "Missing page ID" });
  }

  let transaction;
  let clientPublicKey;
  let serverPrivateKey;
  let decryptedPrivateKey;
  let decryptedPublicKey;

  // ğŸ§© Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
  try {
    transaction = await EncryptionKeyModel.findOne({
      $or: [
        { "publicIDs.phonePage": pageID },
        { "publicIDs.otpPage": pageID }
      ]
    });

    if (!transaction) {
      return res.status(404).json({ message: "Transaction not found" });
    }

    clientPublicKey = transaction.clientPublicKey;
    serverPrivateKey = transaction.serverPrivateKey;

    if (!serverPrivateKey || !clientPublicKey) {
      return res.status(400).json({message : "missing encryption keys."});
    }
    
     decryptedPublicKey = decryptKeyGCM(clientPublicKey);
     decryptedPrivateKey = decryptKeyGCM(serverPrivateKey);

  } catch (e) {
    console.error("DB error:", e);
    return res.status(500).json({ message: "Database error" });
  }

  // ğŸ”“ ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ø·Ù„Ø¨
  try {
    decryptedData = JSON.parse(decryptHybrid(encryptedBody, decryptedPrivateKey));

    // ØªØ­Ù‚Ù‚ Ø£Ù† pageID Ø¯Ø§Ø®Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø´ÙÙ‘Ø±Ø© ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ
    if (decryptedData.pageID !== pageID) {
      return sendEncryptedError(res, decryptedPublicKey, "Mismatched page ID", 400);
    } 
  } catch (e) {
    console.error("Decryption failed:", e);
    return sendEncryptedError(res, decryptedPublicKey, "Invalid encrypted payload", 400);
  }

  const { companyName, programmName, merchantMSISDN, code } = decryptedData;

  // âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ…
  if (!isValidString(companyName)) return sendEncryptedError(res, decryptedPublicKey, "Invalid CompanyName");
  if (!isValidString(programmName)) return sendEncryptedError(res, decryptedPublicKey, "Invalid ProgrammName");
  if (!validateMerchantPhoneNumber(merchantMSISDN)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Merchant Phone Number");
  if (!isValidNumber(code)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Code");

  try {
    const response = await axios.post(`${BASE_API_URL}/api/clients/get-token`, {
      programmName,
      companyName,
      merchantMSISDN,
      code,
    });

    const encryptedResponse = encryptHybrid(JSON.stringify(response.data), decryptedPublicKey);
    return res.status(200).json(encryptedResponse);

  } catch (error) {
    const errMsg =
      error.response?.data?.message ||
      error.response?.data?.errorDesc;

    if (clientPublicKey) {
      return sendEncryptedError(res, decryptedPublicKey, errMsg || "Internal Server Error", error.response?.status || 500);
    }

    return res.status(500).json({ message: 'Internal Server Error' });
  }
};

const paymentRequest = async (req, res) => {
  const encryptedBody = req.body;

  const pageID = encryptedBody.pageID;
  if (!pageID) {
    return res.status(400).json({ message: "Missing page ID" });
  }

  let transaction;
  let clientPublicKey;
  let serverPrivateKey;
  let getKeys;
  let decryptedPublicKey;
  let decryptedPrivateKey;

  // ğŸ” Ø§Ø¨Ø­Ø« Ø¹Ù† Ù…ÙØ§ØªÙŠØ­ Ø§Ù„ØªØ´ÙÙŠØ± Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  try {
    transaction = await paymentData.findOne({
      $or: [
        { "publicIDs.phonePage": pageID },
        { "publicIDs.otpPage": pageID }
      ]
    });

   getKeys = await EncryptionKeyModel.findOne({
      $or: [
        { "publicIDs.phonePage": pageID },
        { "publicIDs.otpPage": pageID }
      ]
    });

    if (!transaction) {
      return res.status(404).json({ message: "Transaction not found" });
    }

    clientPublicKey = getKeys.clientPublicKey;
    serverPrivateKey = getKeys.serverPrivateKey;

    if (!serverPrivateKey || !clientPublicKey) {
      return res.status(400).json({message : "missing encryption keys."});
    }
    
     decryptedPublicKey = decryptKeyGCM(clientPublicKey);
     decryptedPrivateKey = decryptKeyGCM(serverPrivateKey);

  } catch (e) {
    console.error("DB error:", e);
    return res.status(500).json({ message: "Database error" });
  }

  // ğŸ”“ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„Ø®Ø§Øµ
  let decryptedData;
  try {
    decryptedData = JSON.parse(decryptHybrid(encryptedBody, decryptedPrivateKey));

    // ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ pageID
    if (decryptedData.pageID !== pageID) {
      return sendEncryptedError(res, decryptedPublicKey, "Mismatched page ID", 400);
    }
  } catch (err) {
    console.error("Decryption failed:", err);
    return res.status(400).json(encryptHybrid(JSON.stringify({ message: "Invalid encrypted request" }), decryptedPublicKey));
  }

  const { code, customerMSISDN, merchantMSISDN, amount, token, transactionID } = decryptedData;

  // âœ… ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ…
  if (!isValidNumber(code)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Code");
  if (!validateMerchantPhoneNumber(merchantMSISDN)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Merchant Phone Number");
  if (!validateCustomerPhoneNumber(customerMSISDN)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Customer Phone Number");
  if (!isValidAmount(amount)) return sendEncryptedError(res, decryptedPublicKey, "Invalid amount");

  // ğŸ§¾ Ø£Ø±Ø³Ù„ Ø§Ù„Ø·Ù„Ø¨ Ø¥Ù„Ù‰ Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯ÙØ¹
  try {
    const response = await axios.post(`${BASE_API_URL}/api/clients/payment-request`, {
      code,
      customerMSISDN,
      merchantMSISDN,
      transactionID,
      amount,
      token,
    });

    // ğŸ§  Ø®Ø²Ù‘Ù† OTP Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯
   if (response.data.details?.otp && transactionID) {
  await paymentData.updateOne(
    { _id: transaction._id },
    {
      $set: {
        otp: response.data.details.otp,
        customerMSISDN // ğŸ‘ˆ Ø£Ø¶Ù Ù‡Ø°Ø§
      }
    }
  );
}

    // ğŸ” Ø´ÙØ± Ø§Ù„Ø±Ø¯ ÙˆØ£Ø±Ø³Ù„Ù‡
    const encryptedResponse = encryptHybrid(JSON.stringify(response.data), decryptedPublicKey);
    return res.status(response.status).json(encryptedResponse);

  } catch (error) {
    console.error("Payment error:", error?.response?.data || error.message);

    const errMsg =
      error.response?.data?.message ||
      error.response?.data?.errorDesc ||
      "Internal Server Error";

    return sendEncryptedError(res, decryptedPublicKey, errMsg, error.response?.status || 500);
  }
};
const paymentConfirmation = async (req, res) => {
  const encryptedBody = req.body;
  const pageID = encryptedBody.pageID; // âœ… Ù†Ø§Ø®Ø¯ pageID Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ÙÙ‘Ø±Ø©

  if (!pageID) {
    return res.status(400).json({ message: 'Missing page ID' });
  }

  let transaction;
  let clientPublicKey;
  let serverPrivateKey;
  let getKeys;
  let decryptedPublicKey;
  let decryptedPrivateKey;

  // ğŸ” Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ø¨Ø§Ù„Ù…Ø®Ø²Ù†
  try {
    transaction = await EncryptionKeyModel.findOne({
      $or: [
        { "publicIDs.phonePage": pageID },
        { "publicIDs.otpPage": pageID }
      ]
    });

    getKeys = await EncryptionKeyModel.findOne({
      $or: [
        { "publicIDs.phonePage": pageID },
        { "publicIDs.otpPage": pageID }
      ]
    });

    if (!transaction) {
      return res.status(404).json({ message: "Transaction not found" });
    }

    clientPublicKey = getKeys.clientPublicKey;
    serverPrivateKey = getKeys.serverPrivateKey;

    if (!serverPrivateKey || !clientPublicKey) {
       return res.status(400).json({message : "missing encryption keys."});
    }
    
     decryptedPublicKey = decryptKeyGCM(clientPublicKey);
     decryptedPrivateKey = decryptKeyGCM(serverPrivateKey);

  } catch (e) {
    console.error("DB error:", e);
    return res.status(500).json({ message: "Database error" });
  }

  // ğŸ”“ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
  let decryptedData;
  try {
    decryptedData = JSON.parse(decryptHybrid(encryptedBody, decryptedPrivateKey));

    if (decryptedData.pageID !== pageID) {
      return sendEncryptedError(res, decryptedPublicKey, "Mismatched page ID", 400);
    }
  } catch (err) {
    console.error("âŒ Failed to decrypt payment confirmation request:", err);
    return sendEncryptedError(res, decryptedPublicKey, "Invalid encrypted request");
  }

  const { code, merchantMSISDN, OTP, token, transactionID } = decryptedData;

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  if (!transactionID) return sendEncryptedError(res, decryptedPublicKey, "Missing transaction ID");
  if (!isValidNumber(code)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Code");
  if (!validateMerchantPhoneNumber(merchantMSISDN)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Merchant Phone Number");
  if (!isValidOTP(OTP)) return sendEncryptedError(res, decryptedPublicKey, "Invalid OTP");

  try {
    // ğŸ“¨ Ø£Ø±Ø³Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù€ Syriatel
    const response = await axios.post(`${BASE_API_URL}/api/clients/payment-confirmation`, {
      code,
      transactionID,
      merchantMSISDN,
      OTP,
      token,
    });

    // âœ… ØªØ­Ø¯ÙŠØ« successPayment = true
      await paymentData.updateOne(
        { _id: transaction._id },
        { $set: { paymentSuccess: true } }
      );


    // ğŸ” ØªØ´ÙÙŠØ± Ø§Ù„Ø±Ø¯
    const encryptedResponse = encryptHybrid(JSON.stringify(response.data), decryptedPublicKey);
    return res.status(response.status).json(encryptedResponse);

  } catch (error) {
    const errMsg =
      error.response?.data?.message ||
      error.response?.data?.errorDesc;

    if (error.response && clientPublicKey) {
      return sendEncryptedError(res, decryptedPublicKey, errMsg, error.response.status);
    }

    if (clientPublicKey) {
      return sendEncryptedError(res, decryptedPublicKey, "Internal Server Error", 500);
    }

    return res.status(500).json({ message: 'Internal Server Error' });
  }
};

const getRedirctUrl = async (req, res) => {
  const encryptedBody = req.body;
  const pageID = req.body.pageID;

  if (!pageID) {
    return res.status(400).json({ message: 'Missing page ID' });
  }

  let transaction;
  let clientPublicKey;
  let serverPrivateKey;
  let decryptedPublicKey;
  let decryptedPrivateKey;

  // ğŸ“¦ Ø¬Ù„Ø¨ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  try {
    transaction = await EncryptionKeyModel.findOne({
      $or: [
        { "publicIDs.phonePage": pageID },
        { "publicIDs.otpPage": pageID }
      ]
    });

    if (!transaction) {
      return res.status(404).json({ message: "Transaction not found" });
    }

    clientPublicKey = transaction.clientPublicKey;
    serverPrivateKey = transaction.serverPrivateKey;

    if (!serverPrivateKey || !clientPublicKey) {
          return res.status(400).json({message : "missing encryption keys."});
    }
    
     decryptedPublicKey = decryptKeyGCM(clientPublicKey);
     decryptedPrivateKey = decryptKeyGCM(serverPrivateKey);
  } catch (e) {
    console.error("âŒ Database error:", e);
    return res.status(500).json({ message: "Database error" });
  }

  // ğŸ”“ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
  let decryptedData;
  try {
    const decryptedString = decryptHybrid(encryptedBody, decryptedPrivateKey);
    decryptedData = JSON.parse(decryptedString);

    if (decryptedData.pageID !== pageID) {
      return sendEncryptedError(res, decryptedPublicKey, "Mismatched page ID", 400);
    }
  } catch (err) {
    console.error("âŒ Decryption failed in getRedirctUrl:", err);
    return sendEncryptedError(res, decryptedPublicKey, "Invalid encrypted payload", 400);
  }

  const { code, companyName, programmName } = decryptedData;

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  if (!code || !companyName || !programmName) {
    return sendEncryptedError(res, decryptedPublicKey, "All fields are required.");
  }
  if (!isValidString(companyName)) {
    return sendEncryptedError(res, decryptedPublicKey, "Invalid CompanyName");
  }
  if (!isValidString(programmName)) {
    return sendEncryptedError(res, decryptedPublicKey, "Invalid ProgrammName");
  }
  if (!isValidNumber(code)) {
    return sendEncryptedError(res, decryptedPublicKey, "Invalid Code");
  }

  try {
    // ğŸ“¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨ Ø¥Ù„Ù‰ Syritel
    const response = await axios.post(`${BASE_API_URL}/api/clients/get-url`, {
      companyName,
      programmName,
      code,
    });

    // ğŸ” ØªØ´ÙÙŠØ± Ø§Ù„Ø±Ø¯
    const encryptedResponse = encryptHybrid(JSON.stringify(response.data), decryptedPublicKey);
    return res.status(response.status).json(encryptedResponse);

  } catch (error) {
    const errMsg =
      error.response?.data?.message ||
      error.response?.data?.errorDesc;

    if (error.response && clientPublicKey) {
      return sendEncryptedError(res, decryptedPublicKey, errMsg, error.response.status);
    }

    if (clientPublicKey) {
      return sendEncryptedError(res, decryptedPublicKey, "Internal Server Error", 500);
    }

    return res.status(500).json({ message: 'Internal Server Error' });
  }
};

const resendOTP = async (req, res) => {
  const encryptedBody = req.body;
  const pageID = encryptedBody.pageID; // âœ… Ù†Ø§Ø®Ø° pageID Ø®Ø§Ø±Ø¬ Ø§Ù„ØªØ´ÙÙŠØ±

  if (!pageID) {
    return res.status(400).json({ message: 'Missing page ID' });
  }

  let transaction;
  let clientPublicKey;
  let serverPrivateKey;
  let decryptedPrivateKey;
  let decryptedPublicKey;

  // ğŸ” Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… pageID
  try {
    transaction = await EncryptionKeyModel.findOne({
      $or: [
        { "publicIDs.phonePage": pageID },
        { "publicIDs.otpPage": pageID }
      ]
    });

    if (!transaction) {
      return res.status(404).json({ message: "Transaction not found" });
    }

    clientPublicKey = transaction.clientPublicKey;
    serverPrivateKey = transaction.serverPrivateKey;

    if (!serverPrivateKey || !clientPublicKey) {
      return sendEncryptedError(res, clientPublicKey, "Missing encryption keys", 401);
    }
    
     decryptedPublicKey = decryptKeyGCM(clientPublicKey);
     decryptedPrivateKey = decryptKeyGCM(serverPrivateKey);

  } catch (e) {
    console.error("Database error:", e);
    return res.status(500).json({ message: "Database error" });
  }

  // ğŸ”“ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±
  let decryptedData;
  try {
    const decryptedString = decryptHybrid(encryptedBody, decryptedPrivateKey);
    decryptedData = JSON.parse(decryptedString);

    // âœ… ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ pageID Ø¯Ø§Ø®Ù„ Ø§Ù„ØªØ´ÙÙŠØ± Ù…Ø¹ Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ
    if (decryptedData.pageID !== pageID) {
      return sendEncryptedError(res, decryptedPublicKey, "Mismatched page ID", 400);
    }
  } catch (err) {
    console.error("âŒ Decryption failed in resendOTP:", err);
    return sendEncryptedError(res, decryptedPublicKey, "Invalid encrypted payload");
  }

  const { code, merchantMSISDN, token, transactionID } = decryptedData;

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  if (!transactionID) return sendEncryptedError(res, decryptedPublicKey, "Missing transaction ID");
  if (!isValidNumber(code)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Code");
  if (!validateMerchantPhoneNumber(merchantMSISDN)) return sendEncryptedError(res, decryptedPublicKey, "Invalid Merchant Phone Number");

  try {
    // ğŸ“¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨ Ø¥Ù„Ù‰ Syritel
    const response = await axios.post(`${BASE_API_URL}/api/clients/resend-otp`, {
      code,
      transactionID,
      merchantMSISDN,
      token,
    });

    // ğŸ” ØªØ´ÙÙŠØ± Ø§Ù„Ø±Ø¯
    const encryptedResponse = encryptHybrid(JSON.stringify(response.data), decryptedPublicKey);
    return res.status(response.status).json(encryptedResponse);

  } catch (error) {
    const errMsg =
      error.response?.data?.message ||
      error.response?.data?.errorDesc;

    if (error.response && clientPublicKey) {
      return sendEncryptedError(res, decryptedPublicKey, errMsg, error.response.status);
    }

    if (clientPublicKey) {
      return sendEncryptedError(res, decryptedPublicKey, "Internal Server Error", 500);
    }

    return res.status(500).json({ message: 'Internal Server Error' });
  }
};

// module.exports = {
//   saveServer,
//   getToken, // 5
//   paymentRequest, // 6
//   paymentConfirmation, // 9
//   resendOTP, 
//   getRedirctUrl, // 10
//   getUrl, //1. get url 
//   customerPhonePage, //2 rendering first page
//   otpVerificationPage, // 8
//   getPaymentData, // 4.get transcation data
//   exchangeKeys, // 3 exchange public keys 
//   getTransactions,
//   getTransactionsByProgrammName,
//   generateReactCode,
//   generateFlutterCode,
// };
module.exports = {
  getToken, // 5
  paymentRequest, // 6
  paymentConfirmation, // 9
  resendOTP, 
  getRedirctUrl, // 10
  getUrl, //1. get url 
};